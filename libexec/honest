#!/usr/bin/env bash
#
# Usage: honest [-h/--help] [-V/--version]
#               <git-url>
#               <package> [-v=]
# Examples:
#        honest --version
#        honest github:david942j/one_gadget gem:one_gadget
#        honest https://github.com/pypa/setuptools@v39.0.1 pip:setuptools -v 39.0.1
#        honest ~/path_on_my_laptop/seccomp-tools gem:seccomp-tools -v 1.2.0
#
# Options:
#        -h, --help
#               Show this usage.
#        -V, --version
#               Display version information and exit.
#
# Git Url Parameter:
#        <git-url> can be:
#               - A relative/absolute path.
#               - https://<git org>/<author>/<project>[@<branch|commit|tag>]
#               - <github|bitbucket|gitlab>:<author>/<project>[@<branch|commit|tag>]
#        If no branch/commit/tag is specified, the latest release(tag) will be used.
#        With this behavior we can have the simplest usage of honest: `$ honest github:user/proj pip:proj`.

# Compatibility to MAC
[[ "$OSTYPE" == "darwin"* ]] && readlink() { echo $(cd $(dirname "$2") && pwd)/$(basename "$2"); }

SCRIPT_DIR="$(readlink -f "$(dirname "$0")")"
# Import common functions and variables of honest
source "$SCRIPT_DIR"/../share/honest/honest-common.sh

# -------- Commonly used variables -------
HONEST_ROOT="$SCRIPT_DIR"/..
HONEST_SHARE="$HONEST_ROOT"/share/honest
export PATH="$HONEST_ROOT/libexec:$PATH"

HONEST_TMP_DIRS=()

clear_tmp_dirs() {
  rm -fr "${HONEST_TMP_DIRS[@]}"
}

push_tmp() {
  HONEST_TMP_DIRS+=("$1")
}

#######################################
# Download the git repo of a git package.
# Globals:
#   None
# Arguments:
#   <Package> The package name with format '<vendor>:<author>/<project>[@..]'
# Returns:
#   None
#   Set global variable 'REPO_PATH'
#######################################
fetch_repo() {
  if [[ -d "$1" ]]; then
    REPO_PATH="$1"
    info "Use local repo directory '$1'"
  else
    info "Fetching the repo '$1'..."
    REPO_PATH="$(honest-clone "$1")"
    [[ $? != 0 ]] && die "Fail on fetching repo '$1'"
    push_tmp "$REPO_PATH"
  fi
}

#######################################
# Interface function for downloading packages from any vendors.
# Globals:
#   None
# Arguments:
#   <Vendor>
#   <Package Name>
#   [Package version] Optional package version specified by user
# Returns:
#   None
#   Set global variable 'PACKAGE_PATH'
#######################################
download_package() {
  local cmd=()
  local vendor=$1
  local pkg=$2
  local ver=$3

  # Compile the command
  cmd+=(honest-$vendor)
  cmd+=(download $pkg)
  [[ "$ver" != "" ]] && cmd+=(-v $ver)

  # Execute the command and get the return string
  info "Downloading the package '$pkg'..."
  PACKAGE_PATH="$(${cmd[@]})"
  [[ $? != 0 ]] && die "Fail on running '${cmd[@]}'"
  push_tmp "$PACKAGE_PATH"
}

vendor_diff() {
  local vendor=$1
  local pkg=$2
  local src=$3
  local tgt=$4

  info "Calculating the honesty..."
  case "$vendor" in
    gem )
      /usr/bin/env ruby "$HONEST_SHARE"/gem/diff.rb $src $tgt
      ;;
    * )
      die "Vendor '$vendor' is currently not supported"
      ;;
  esac
  if [[ $? -eq 0 ]]; then
    info "OK, ${YELLOW}$pkg${NC} is ${GREEN}Honest${NC}!"
    clear_tmp_dirs
  else
    git --no-pager diff --no-index --diff-filter=M "$REPO_PATH" "$PACKAGE_PATH"/data
    info "NO, ${YELLOW}$pkg${NC} is ${RED}Unhonest${NC}!"
  fi
}

main() {
  local package_ver=""
  local args=()

  # Parse arguments
  while [[ "$1" != "" ]]; do
    case "$1" in
      -h|--help )
        usage
        exit 0
        ;;
      -V|--version)
        version
        exit 0
        ;;
      -v)
        package_ver="$2"
        shift 2
        ;;
      * )
        # Exit on argument starting with hyphen "-"
        [[ "$1" == "-"* ]] && die "Unknown argument $1"
        # Remember the string type arguments in the array
        args+=("$1")
        shift
        ;;
    esac
  done

  # Check # of input arguments after parsing the input arguments
  [[ ${#args[@]} == 0 ]] && usage && exit 1
  [[ ${#args[@]} < 2 ]] && die "Both <git-url> and <package> are required!"

  # Check the format and exit on any failure
  check_package_format "${args[1]}"
  # Match the first : and extract vendor/pkg name
  local vendor=${args[1]%%:*}
  local pkg=${args[1]#*:}

  fetch_repo "${args[0]}"
  download_package $vendor $pkg $package_ver
  vendor_diff $vendor $pkg "$REPO_PATH" "$PACKAGE_PATH"
}

main "$@"
